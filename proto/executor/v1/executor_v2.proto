syntax = "proto3";

package executor.v1;
import "executor/v1/executor_common.proto";

option go_package = "github.com/0xPolygonHermez/zkevm-node/state/runtime/executor";

// Sequencer Must always call with flag 'mock_verify_ger' set to 1
// Either Sequencer or Executor should provide the fake smtProof

message ProcessBatchRequestV2 {
    bytes old_state_root = 1;
    bytes old_acc_input_hash = 2;
    uint64 old_batch_num = 3;
    uint64 chain_id = 4;
    uint64 fork_id = 5;
    bytes batch_l2_data = 6;
    bytes l1_info_root = 7;
    uint64 timestamp_limit = 8;
    string coinbase = 9;
    bytes forced_blockhash_l1 = 10;
    // flag to indicate if the merkle tree needs to be updated
    uint32 update_merkle_tree = 11;
    // flag to indicate that counters should not be taken into account
    uint32 no_counters = 12;
    // from is used for unsigned transactions with sender
    string from = 13;
    // flag to skip the check when l1Data is verified
    uint32 skip_verify_l1_info_root = 14;
    // flag to skip the restriction to start a batch with a changeL2Block transaction
    uint32 skip_first_change_l2_block = 15;
    // lInfoTree information
    map<uint32, L1DataV2> l1_info_tree_data = 16;
    // For testing purposes only
    map<string, string> db = 17;
    map<string, string> contracts_bytecode = 18; // For debug/testing purpposes only. Don't fill this on production
    TraceConfigV2 trace_config = 19;
    string context_id = 20;
    uint32 get_keys = 21; // if 1, the keys used to read or write storage values will be returned
    // The state override set is an optional address-to-state mapping,
    // where each entry specifies some state to be ephemerally overridden
    // prior to executing the call.
    map<string, OverrideAccountV2> state_override = 22;
}

message L1DataV2 {
    bytes global_exit_root = 1;
    bytes block_hash_l1 = 2;
    uint64 min_timestamp = 3;
    repeated bytes smt_proof = 4;
}

message ProcessBatchResponseV2 {
    bytes new_state_root = 1;
    bytes new_acc_input_hash = 2;
    bytes new_local_exit_root = 3;
    uint64 new_batch_num = 4;
    uint32 cnt_keccak_hashes = 5;
    uint32 cnt_poseidon_hashes = 6;
    uint32 cnt_poseidon_paddings = 7;
    uint32 cnt_mem_aligns = 8;
    uint32 cnt_arithmetics = 9;
    uint32 cnt_binaries = 10;
    uint32 cnt_steps = 11;
    repeated ProcessBlockResponseV2 block_responses = 12;
    ExecutorError error = 13;
    map<string, InfoReadWriteV2> read_write_addresses = 14;
    uint64 flush_id = 15;
    uint64 stored_flush_id = 16;
    string prover_id = 17;
    uint64 gas_used = 18;
    repeated bytes nodes_keys = 19;
    repeated bytes program_keys = 20;
    uint64 fork_id = 21;
}

// Trace configuration request params
message TraceConfigV2 {
    // Disables storage (default=false)
    uint32 disable_storage = 1;
    // Disables stack (default=false)
    uint32 disable_stack = 2;
    // Enables memory (default=false)
    uint32 enable_memory = 3;
    // Enables return data (default=false)
    uint32 enable_return_data = 4;
    // Hash of tx in batch to retrieve the trace
    bytes tx_hash_to_generate_full_trace = 5;
}

// OverrideAccount indicates the overriding fields of account during the execution
// of a message call.
// Note, state and stateDiff can't be specified at the same time. If state is
// set, message execution will only use the data in the given state. Otherwise
// if statDiff is set, all diff will be applied first and then execute the call
// message.
message OverrideAccountV2 {
    // Fake balance to set for the account before executing the call.
    bytes balance = 1;
    // Fake nonce to set for the account before executing the call.
    uint64 nonce = 2;
    // Fake EVM bytecode to inject into the account before executing the call.
    bytes code = 3;
    // Fake key-value mapping to override all slots in the account storage before executing the call.
    map<string, bytes> state = 4;
    // Fake key-value mapping to override individual slots in the account storage before executing the call.
    map<string, bytes> state_diff = 5;
}

message InfoReadWriteV2 {
    // If nonce="" then it has not been set; if set, string is in decimal (base 10)
    string nonce = 1;
    // If balance="" then it has not been set; if set, string is in decimal (base 10)
    string balance = 2;
}

message FullTraceV2 {
    TransactionContextV2 context = 1;
    repeated TransactionStepV2 steps = 2;
}

message TransactionContextV2 {
    // CALL or CREATE
    string type = 1;
    // Sender of the transaction
    string from = 2;
    // Target of the transaction
    string to = 3;
    // Input data of the transaction
    bytes data = 4;
    // Gas of the transaction
    uint64 gas = 5;
    // Value of the transaction
    string value = 6;
    // Hash of the block in which the transaction was included
    bytes block_hash = 7;
    // Returned data from the runtime (function result or data supplied with revert opcode)
    bytes output = 8;
    // Total gas used as result of execution
    uint64 gas_used = 9;
    // Gas Price
    string gas_price = 10;
    // Execution Time
    uint32 execution_time = 11;
    // Starting state root
    bytes old_state_root = 12;
    // The number of transactions made by the sender prior to this one
    uint64 nonce = 13;
    // The integer of the transaction's index position in the block
    uint64 tx_index = 14;
    // The chain id of the transaction, if any
    uint64 chain_id = 15;
}

message TransactionStepV2 {
    bytes state_root = 1;
    // Call depth
    uint32 depth = 2;
    // Program counter
    uint64 pc = 3;
    // Remaining gas
    uint64 gas = 4;
    // Gas cost of the operation
    uint64 gas_cost = 5;
    // Gas refunded during the operation
    uint64 gas_refund = 6;
    // Opcode
    uint32 op = 7;
    // Content of the stack
    repeated string stack = 8;
     // Content of memory, starting at memory_offset, showing only changes vs. previous step
    bytes memory = 9;
    // Total size of memory
    uint32 memory_size = 10;
    // Offset of memory changes
    uint32 memory_offset = 11;
    // Return Data
    bytes return_data = 12;
    // Contract information
    ContractV2 contract = 13;
    // Error
    RomError error = 14;
    // Content of the storage
    map<string, string> storage = 15;
}

message ContractV2 {
    string address = 1;
    string caller = 2;
    string value = 3;
    bytes data = 4;
    uint64 gas = 5;
    // Define type of internal call: CREATE, CREATE2, CALL, CALLCODE, DELEGATECALL, STATICCALL
    string type = 6;
}

message ProcessBlockResponseV2 {
    // The hash of the parent block. Must match the old_state_root
    bytes parent_hash = 1;
    // l2 coinbase
    string coinbase = 2;
    // The maximum gas allowed in this block
    uint64 gas_limit = 3;
    // block number
    uint32 block_number = 4;
    // timestamp used in the block
    uint64 timestamp = 5;
    // global exit root l1InfoTree
    bytes ger = 6;
    // block hash L1
    bytes block_hash_l1 = 7;
    // The total used gas by all transactions in this block
    uint64 gas_used = 8;
    // The root of the block info tree
    bytes block_info_root = 9;
    // block hash (should match the new state root)
    bytes block_hash = 10;
    // transaction responses
    repeated ProcessTransactionResponseV2 responses = 11;
    // All Logs emited by LOG opcode during the block
    repeated LogV2 logs = 12;
}

message ProcessTransactionResponseV2 {
    // Hash of the transaction
    bytes tx_hash = 1;
    // Hash of the transaction computed by the ROM
    bytes tx_hash_l2 = 2;
    // RLP encoded transaction
    // [nonce, gasPrice, gasLimit, to, value, data, v, r, s]
    bytes rlp_tx = 3;
    // The hash of the block where this transaction was included
    bytes block_hash = 4;
    // The block number where this transaction was included
    uint64 block_number = 5;
    // Type indicates legacy transaction
    // It will be always 0 (legacy) in the executor
    uint32 type = 6;
    // Returned data from the runtime (function result or data supplied with revert opcode)
    bytes return_value = 7;
    // Total gas left as result of execution
    uint64 gas_left = 8;
    // Total gas used as result of execution or gas estimation
    uint64 gas_used = 9;
    // Cumulative gas used by this tranaction in the block
    uint64 cumulative_gas_used = 10;
    // Total gas refunded as result of execution
    uint64 gas_refunded = 11;
    // Any error encountered during the execution
    RomError error = 12;
    // New SC Address in case of SC creation
    string create_address = 13;
    // State Root
    bytes state_root = 14;
    // All Logs emited by LOG opcode during this transaction
    repeated LogV2 logs = 15;
    // Trace
    FullTraceV2 full_trace = 16;
    // Efective Gas Price
    string effective_gas_price = 17;
    uint32 effective_percentage = 18;
    // Flag to indicate if opcode 'GASPRICE' has been called
    uint32 has_gasprice_opcode = 19;
    // Flag to indicate if opcode 'BALANCE' has been called
    uint32 has_balance_opcode = 20;
}

message LogV2 {
    // Address of the contract that generated the event
    string address = 1;
    // List of topics provided by the contract
    repeated bytes topics = 2;
    // Supplied by the contract, usually ABI-encoded
    bytes data = 3;
    // Batch in which the transaction was included
    uint64 block_number = 4;
    // Hash of the transaction
    bytes tx_hash = 5;
    // Hash of the transaction L2 computed by the rom
    bytes tx_hash_l2 = 6;
    // Index of the transaction in the block
    uint32 tx_index = 7;
    // Hash of the block in which the transaction was included
    bytes block_hash = 8;
    // Index of the log in the block
    uint32 index = 9;
}